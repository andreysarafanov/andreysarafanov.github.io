<!doctype html>
<html lang="en">	
<head>
	<meta charset="utf-8">
	<title>Reveal.js 3 Slide Demo</title>
	<link rel="stylesheet" href="css/reveal.min.css">
	<link rel="stylesheet" href="css/theme/serif.css" id="theme">	
	<script type="text/x-mathjax-config">
	  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
	</script>
	<script type="text/javascript"
	  src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
	</script>
	<style>
	p {
		text-align: left;
	}
	p.right {
		text-align: right;
	}
	.image {
		border: 0px;
		padding: 0px;
	}
	.white {
		background: #ffffff !important
		background-color: #ffffff !important
	}
	</style>
</head>

<body class="white">
	<!-- Wrap the entire slide show in a div using the "reveal" class. -->
	<div class="reveal">
		<!-- Wrap all slides in a single "slides" class -->
		<div class="slides">

			<!-- ALL SLIDES GO HERE -->
			<!-- Each section element contains an individual slide -->
			<section data-transition="none">
				<br/><br/><br/><br/><br/>
				<h2>Элементы теории кодов. Системы Линденмайера.</h2>
				<p class="right">Докладчик: Сарафанов Андрей, группа 524.</p>
			</section>
			<section data-transition="none">
				<h2>План доклада</h2>
				<ul>
					<li>Понятие кода. Некоторые свойства кодов.</li>
					<li>Катенативно-независимые языки. Критерий Шутценберже.</li>
					<li>Алгоритм Сардинаса-Паттерсона.</li>
					<li>Индикаторные суммы. Префиксные коды.</li>
					<li>Коды с ограниченной задержкой.</li>
					<li>Оптимальные коды. Алгоритм Хафмана.</li>
					<li>Системы Линденмайера.</li>
				</ul>
			</section>

			<section data-transition="none">
				<h2>Понятие кода</h2>
				<p>Язык $L$ называется <b>кодом</b>, если он не пуст и любое слово из $L^*$ может быть единственным образом представлено как конкатенация слов из $L$.</p>
				<p>То есть, если $u_1,\dots,u_m,v_1,\dots,v_n$ - слова языка $L$ и $u_1 \cdot\cdot\cdot u_m = v_1 \cdot\cdot\cdot v_n,$ то $u_1 = v_1$.</p>
			</section>

			<section data-transition="none">
				<h2>Некоторые свойства кодов</h2>
				<ul>
					<li>Код не может содержать пустое слово.</li>
					<li>Непустое подмножество кода является кодом.</li>
					<li>Код над унарным алфавитом может состоять только из одного слова.</li>
					<li>Множество кодов замкнуто относительно операций пересечения, зеркального отображения, возведения в степень.</li>
				</ul>
			</section>

			<section data-transition="none">	
				<h2>Катенативно-независимые языки</h2>
				<p>Язык $L$ будем называть <b>катенативно-независимым</b>, если $$L \cap LL^+ = \emptyset.$$</p>
				<p>Каждый код является катенативно-независимым языком, но обратное в общем случае не верно.</p>
			</section>

			<section data-transition="none">
				<h2>Критерий Шутценберже</h2>
				<p>Катенативно-независимый язык $L$ над алфавитом $\Sigma$ является кодом тогда и только тогда, когда для любого $w \in \Sigma^*$ верно утверждение: $$\exists t,x,y,z \in L^* : wt=x, yw=z \implies w \in L^*$$</p>
			</section>

			<section data-transition="none">
				<h2>Алгоритм Сардинаса-Паттерсона</h2>
				<p>Критерий Шутценберже не предоставляет алгоритма для определения, является ли конечный язык $L$ кодом. Одним из решающих эту задачу алгоритмов является алгоритм Сардинаса-Паттерсона.</p>
				<ol>
					<li>Присвоить $i \leftarrow 0$, $L_i \leftarrow L$.</li>
					<li>Присвоить $i \leftarrow i+1$, $L_i \leftarrow \{w| w \neq \Lambda, \:где\: xw=y \:или\: yw=x \:для\: некоторых\\ x \in L, y\in L_{i-1}\}$</li>
					<li>Если $L_i \cap L \neq \emptyset$, то вернуть "нет" и выйти.</li>
					<li>Если $\exists j \in \mathbb{N}, j &lt; i: L_i = L_j$, то вернуть "да" и выйти.</li>
					<li>Перейти на пункт 2.</li>
				</ol>
			</section>
			<section data-transition="none">
				<h2>Индикаторная сумма</h2>
				<p>Пусть задан язык $L$ над алфавитом $\Sigma, |\Sigma| = M$. Тогда индикаторной суммой назовём функцию от $L$: $$is(L) = \sum\limits_{w \in L} M^{-|w|}$$</p>
			</section>
			<section data-transition="none">
				<h2>Теорема Маркова-Макмиллана</h2>
				<p><b>Теорема Маркова-Макмиллана. </b>Для любого кода $L:$ $is(L) \leq 1$</p>
				<p><b>Следствие. </b>Если $L$ - код и $is(L) = 1$, то $L$ является максимальным кодом, то есть не является собственным подмножеством никакого другого кода.</p>
			</section>
			<section data-transition="none">
				<h2>Теорема Крафта</h2>
				<p>Пусть есть последовательность натуральных чисел $l_1,\dots:$ $l_1 \leq l_2 \leq \dots \leq l_n$</p>
				<p><b>Теорема Крафта. </b>Если $\sum_{n=1,2,\dots} M^{-l_n} \leq 1$, то существует код над алфавитом мощности $M$, такой, что длины его слов равны $l_1,l_2,\dots$. К тому же, в качестве такого кода всегда может быть выбран префикный код, т.е. такой код, ни одно слово которого не является префиксом другого слова.</p>
				<p><b>Следствие. </b>Любой код можно заменить префиксным кодом над тем же алфавитом с сохранением длин слов.</p>
			</section>
			<section data-transition="none">
				<h2>Коды с ограниченной задержкой</h2>
				<p>Будем говорить, что у кода есть <b>задержка декодирования p</b>, если для декодирования одного кодового слова необходимо заглянуть на p слов вперед. То есть, <br/>
				$u_1,\dots ,u_p, v_1, \dots, v_n \in L,  v_1 \dots v_n = u_1\dots u_p w \\ \implies v_1 = u_1$</p>
				<p>Коды, обладающие задержкой декодирования, будем называть <b>кодами с ограниченной задержкой</b> (bounded-delay codes).</p>
				<p>Для декодирования любого конечного кода с ограниченной задержкой можно построить обобщенную последовательную машину (generalized sequential machine).</p>
			</section>

			<section data-transition="none">
				<section data-transition="none">
					<h2>Оптимальные коды</h2>
					<p>Пусть задан алфавит $\Sigma$ и набор значений $P_1, P_2, \dots, P_k \in \mathbb{R}_+$, $\sum\limits_{i=1}^k P_i = 1$.</p>
					<p>Тогда <b>оптимальным кодом</b> над алфавитом $\Sigma$ с весовыми коэффициентами $\{P_i\}$ будет такой конечный код, состоящий из слов $w_1, \dots, w_k$, при котором сумма $\sum\limits_{i=1}^k P_i|w_i|$ будет принимать наименьшее значение.</p>
				</section>
				<section data-transition="none">
					<h2>Оптимальные коды</h2>
					<p><b>Лемма. </b>Кодовые слова $w_1, \dots, w_k $ оптимального префиксного кода могут быть выбраны таким образом, что</p>
					<ul>
						<li>$l_1 \leq \cdots \leq l_{k-s} \leq l_{k-s+1} = \cdots = l_k, \\ 2 \leq s \leq M, s = k \: mod\: M -1$</li>
						<li>$w_{k-s+1}, \dots, w_k$ различаются только последними символами</li>
						<li>общий префикс длины $l_k - 1$ слов $w_{k-s+1}, \dots, w_k$ <br/> не является префиксом ни для одного слова из $w_{1}, \dots w_{k-s}$</li>
					</ul>
				</section>
			</section>

			<section data-transition="none">
				<h2>Алгоритм Хоффмана</h2>
				<img class="image" src="images/hoffman_alg.png"/>
			</section>

			<section data-transition="none">
				<h2>Системы Линденмайера</h2>
				<p><b>Контекстно-свободная система Линденмайера (КС L-система)</b> - тройка $G=(\Sigma, \alpha,P)$, где $\Sigma$ - алфавит, $\alpha \in \Sigma^*$ - аксиома, $P$ - правила вывода. Для каждого символа $s \in \Sigma$ должно быть как минимум одно правило вывода вида $s \rightarrow w$. КС-системы в дальнейшнем будет обозначать префиксом $0$.</p>
				<p>КС L-система называется <b>детерминированной</b>, если для каждого символа $s \in \Sigma$ в $P$ присутствует ровно одно соответствующее правило вывода. Детерминированность в дальнейшем будем обозначать префиксом $D$.</p>
			</section>
			<section data-transition="none">
				<h2>Системы Линденмайера</h2>
				<p>КС L-система называется <b>неукорачивающей</b>, если для каждого правила вывода $s \rightarrow w$ выполняется $w \neq \Lambda$. Это свойство в дальнейшем будем обозначать префиксом $P$.</p>
				<p>Множество языков, задаваемых группой L-систем, будем обозначать как $\mathcal{L}(L)(\mathcal{L}(0L), \mathcal{L}(PL))$ и т.д.</p>
			</section>	

			<section data-transition="none">
				<h2>Системы Линденмайера</h2>
				<p><b>Теорема. </b>$\mathcal{L}(0L) \subset КЗ$.</p>
				<p>К тройке $G=(\Sigma, \alpha,P)$ можно добавить алфавит терминальных символов $\Sigma_T$, получив четверку $G'=(\Sigma,\Sigma_T,\alpha,P)$. Генерируемый язык тогда задаётся как $\mathcal{L}(G')=\{w | \alpha \implies_{G'}^* w, w \in \Sigma_T^*\}$. Наличие терминальных символов в дальнейшем обозначается префиксом $E$.</p>
				<p><b>Теорема. </b> $КС \subset \mathcal{L}(E0L) \subset КЗ.$</p>
			</section>

			<section data-transition="none">
				<h2>КЗ L-системы</h2>
				<p>Контекстно-зависимая L-система - пятерка $G = (\Sigma, X_L, X_R, \alpha, P)$, где $\Sigma$ - алфавит, 
				$X_R,X_L \not\in \Sigma$ - правый и левый маркеры конца, $\alpha$ - аксиома, $P$ - правила вывода. Правила вывода имеют специальный вид: $\langle u,a,v\rangle \rightarrow w$, где $a \in \Sigma$, $u$ - левый контекст, $v$ - правый контекст.</p>
				<p><b>Теорема. </b> $\mathcal{L}(EPIL) = КЗ$, $\mathcal{L}(EIL)$ эквивалентно грамматикам типа 0.</p>
				<p><b>Теорема. </b> $\mathcal{L}(EPDIL) = ДКЗ$, $\mathcal{L}(EDIL)$ эквивалентно грамматикам типа 0.</p>
			</section>

			<section data-transition="none">
				<section data-transition="none">
					<h2>Пример использования L-системы</h2>
					<p>Рассмотрим EL-систему $(\{0,1\},\{0,1,[,]\}, 0, \{1 \rightarrow 11, 0 \rightarrow 1[0]0\})$</p>
					<p>Её результаты на первых шагах:</p>
					<ol>
						<li>0</li>
						<li>1[0]0</li>
						<li>11[1[0]0]1[0]0</li>
						<li>1111[11[1[0]0]1[0]0]11[1[0]0]1[0]0</li>
					</ol>
				</section>
				<section data-transition="none">
					<h2>Пример использования L-системы</h2>
					<p>Придадим каждому терминальному символу графическое значение. <br/>
					$0$ - отрисовка ветви с листовой вершиной на конце <br/>
					$1$ - отрисовка ветви <br/>
					$[$ - push положения и угла в стек, поворот на 45 градусов против часовой стрелки <br/>
					$]$ - pop положения и угла из стека, поворот на 45 градусов по часовой стрелке <br/>
					</p>
				</section>
				<section data-transition="none">
					<h2>Пример использования L-системы</h2>
					<h3>0 шаг</h3>
					<img class="image" src="images/L0.png"/>
				</section>
				<section data-transition="none">
					<h2>Пример использования L-системы</h2>
					<h3>1 шаг</h3>
					<img class="image" src="images/L1.png"/>
				</section>
				<section data-transition="none">
					<h2>Пример использования L-системы</h2>
					<h3>2 шаг</h3>
					<img class="image" src="images/L2.png"/>
				</section>
				<section data-transition="none">
					<h2>Пример использования L-системы</h2>
					<h3>3 шаг</h3>
					<img class="image" src="images/L3.png"/>
				</section>
				<section data-transition="none">
					<h2>Пример использования L-системы</h2>
					<h3>4 шаг</h3>
					<img class="image" src="images/L4.png"/>
				</section>
				<section data-transition="none">
					<h2>Пример использования L-системы</h2>
					<h3>7 шаг</h3>
					<img class="image" src="images/L7.png"/>
				</section>
			</section>

			<section data-transition="none">
				<br/><br/><br/><br/><br/>
				<h2>Вопросы?</h2>
			</section>

			</div>
	</div>
	<script src="lib/js/head.min.js"></script>
	<script src="js/reveal.min.js"></script>

	<script>
		// Required, even if empty.
		Reveal.initialize({
		});
	</script>
</body>
<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
  if( window.location.search.match( /print-pdf/gi ) ) {
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = 'css/print/pdf.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  }
</script>
</html>
